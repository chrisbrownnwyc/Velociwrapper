{"name":"Velociwrapper","tagline":"Velociwrapper is a wrapper to create models around ElasticSearch","body":"Velociwrapper\r\n=============\r\n\r\nVelociwrapper is a wrapper to create ORM like features around Elasticsearch indexes.\r\nVelociwrapper is not a true ORM since Elasticsearch isn't a relational database\r\n\r\nGetting Started\r\n---------------\r\n\r\n::\r\n\t\r\n\t# configuration\r\n\timport velociwrapper\r\n\tvelociwrapper.config.dsn = [\"localhost\"]\r\n\tvelociwrapper.config.default_index = 'my_elasticsearch_index'\r\n\tvelociwrapper.config.results_per_page = 50\r\n\t\r\n\tfrom velociwrapper import VWBase, VWCollection\r\n\tfrom velociwrapper.es_type import String, Integer, DateTime\r\n\tfrom velociwrapper.mapper import Mapper # for creating or reindexing indexes\r\n\r\n\t# create models, similar to SQLAlchemy\r\n\r\n\tclass User(VWBase):\r\n\t\t\r\n\t\t__index__ = 'user_index'  # each model can have a custom index. If omitted, uses the default\r\n\t\t__type__ = 'user' # each model most specify the type. Cooresponds to the doc_type in Elasticsearch\r\n\r\n\t\tusername = String(analyzed=False) # keyword arguments can be used to affect the mapping \r\n\t\tpassword = String(analyzed=False)\r\n\t\temail = String()\r\n\t\tpermission_level = String('default_permission', analyzed=False) # ES Types can have default values\r\n\t\tname = '' # Velociwrapper will automatically convert python types to the appropriate type (but you can't specify mappings)\r\n\t\tcreated = DateTime() # defaults to current time\r\n\t\taddress = {} # models can also have nested information\r\n\r\n\t# define a collection. You only need to specify the model\r\n\tclass Users(VWCollection):\r\n\t\t__model__ = User\r\n\r\n\t\r\n\tif __name__ == '__main__':\r\n\t\t# create indexes\r\n\t\tMapper().create_indices() # creates all defined VWBase models\r\n\r\n\t\t# create a model\r\n\t\tuser = User(\r\n\t\t\tusername='johndoe',\r\n\t\t\tpassword=some_encrypt_method('password'),\r\n\t\t\temail='johndoe@example.com',\r\n\t\t\tpermission_level='admin',\r\n\t\t\tname='John Doe',\r\n\t\t\taddress={ 'street': '123 Some Street', 'city':'Somewhere','state':'TX','zip':'75000' }\r\n\t\t\t)\r\n\t\t\r\n\t\t# commit the info to the index\r\n\t\tuser.commit()\r\n\r\n\t\t# (id is created automatically unless specified)\r\n\t\t\r\n\t\t# data is retrieved using a collection class\r\n\r\n\t\t# search for a user by id\r\n\t\tuser_by_id = Users().get(user.id)\r\n\r\n\t\t# search by another field and return 1 \r\n\t\tuser_by_username = Users().filter_by(username='johndoe').one()\r\n\r\n\t\t# search by multiple fields\r\n\t\tuser_by_fields = Users().filter_by(username='johndoe', email='johndoe@example.com').one()\r\n\r\n\t\t# or chain search conditions together\r\n\t\tuser_by_fields = Users().filter_by(username='johndoe').filter_by(email='johndoe@example.com').one()\r\n\r\n\t\t# specify boolean conditions. ( all() gets all related records for the page)\r\n\t\tusers = Users().filter_by(username='johndoe', email='quazimoto@example.com', condition='or').all()\r\n\r\n\t\t# find out how many records match the criteria in the entire index\r\n\t\tuser_count = Users().filter_by(username='johndoe', email='quazimoto@example.com', condition='or').count()\r\n\r\n\t\t# or using len()\r\n\t\tuser_count = len(Users().filter_by(username='johndoe', email='quazimoto@example.com', condition='or'))\r\n\r\n\t\t# nested objects can automatically be searched as well\r\n\t\tusers = Users().filter_by(city='Somewhere').all()\r\n\r\nVelociwrapper can do many more things. Read on!\r\n\r\n-----\r\n\r\nDear God, Why?\r\n--------------\r\n\r\nLike most things it started off as a useful tool and took on a life of its own.\r\nWe had a ton of code written around SQLAlchemy but wanted the power and convience of\r\nElasticSearch. We started off mapping results to objects and then added methods that make\r\nwriting most searches easier.\r\n\r\nConfiguration\r\n-------------\r\n\r\n*velociwrapper.config.dsn*\r\n\r\nA list of nodes to connect to. Each node can be a string hostname or a dict with options. \r\nSee http://elasticsearch-py.readthedocs.org/en/master/api.html#elasticsearch.Elasticsearch for valid values. \r\n(sets the value of the ``hosts`` parameter).  Defaults to ``localhost``.\r\n\r\n*velociwrapper.config.connection_params*\r\n\r\nA ``dict`` of additional parameters to pass to the client connection. \r\nSee http://elasticsearch-py.readthedocs.org/en/master/api.html#elasticsearch.Elasticsearch\r\nDefaults to ``{}``\r\n\r\n*velociwrapper.config.default_index*\r\n\r\nA string index to use if it is not specified in the model. Defaults to ``es_model``\r\n\r\n*velociwrapper.config.bulk_chunk_size*\r\n\r\nA few calls such as ``VWCollection.delete()``, ``VWCollection.commit()``, or  ``Mapper.reindex()`` can act on\r\nlarge collections. The ``bulk_chunk_size`` tells Elasticsearch how many records to operate on at a time.\r\nDefaults to 1000\r\n\r\n*velociwrapper.config.results_per_page*\r\n\r\nFor performance reasons Elasticsearch will not return large numbers of documents in a single call. As such\r\nreturn values are limited. This value is the default results but you can also pass the parameter to ``all()``\r\nto change the result for a single value. Defaults to 50\r\n\r\n*velociwrapper.config.strict_types*\r\n\r\nPerform type checks when creating objects. When ``True`` velociwrapper will throw an exception if the value\r\nyou're setting doesn't match the attribute's assigned type.\r\n\r\n**Configuration using environment variables**\r\n\r\nAll configuration variables can be set via the environment. \r\n\r\n``VW_DSN`` maps to ``dsn``. Can be a comma separated string or JSON\r\n\r\n``VW_CONNECTION_PARAMS`` maps to ``connection_params``. Must be JSON\r\n\r\n``VW_DEFAULT_INDEX`` maps to ``default_index``.  String\r\n\r\n``VW_BULK_CHUNK_SIZE`` maps to ``bulk_chunk_size``\r\n\r\n``VW_RESULTS_PER_PAGE`` maps to ``results_per_page``\r\n\r\n----\r\n\r\nTypes\r\n------------------\r\n\r\nElasticsearch is extremely flexible when it comes to adding types but less forgiving about changing them. To\r\nhelp with this we created a metaclass called ``ESType`` to define mappings used in Elasticsearch. The types are \r\nused when ``strict_types`` is on and both the mapping options and types are used when creating or reindexing the\r\nindices.  The mapping options are set in the metaclass, otherwise the types subclass normal Python types and \r\nare used the same way.\r\n\r\nUsing Velociwrapper's types is completely optional. If you define the models using normal Python types, everything\r\nwill work as expected. The biggest drawback is that Velociwrapper will not automatically be able to use filter\r\nsyntax on ``not_analyzed`` string fields.\r\n\r\nAll defaults in Velociwrapper's types are set to Elasticsearch's defaults:\r\nhttp://www.elasticsearch.org/guide/en/elasticsearch/reference/current/mapping-core-types.html\r\n\r\nIn cases where the option begins with \"_\" Velociwrapper requires the underscore be appended rather than prepended.\r\n\r\n**Available Types**\r\n\r\n**String** *([str],\\*\\*kwargs)*\r\n\t\r\nKeyword args:\r\n\r\n- ``analyzed``\r\n- ``norms``\r\n- ``index_options``\r\n- ``analyzer``\r\n- ``index_analyzer``\r\n- ``search_analyzer``\r\n- ``ignore_above``\r\n- ``position_offset_gap``\r\n- ``value_``\r\n- ``boost_``\r\n\r\nThe ``analyzed`` argument maps to ``index=analyzed|not_analyzed`` default is ``analyzed``\r\n\r\n**Number** *([number], \\*\\*kwargs)*\r\n\r\nGeneric number type. Normally you should use the number type classes that derive from this. If ``type`` is omitted\r\ndefaults to ``float``\r\n\r\nKeyword args:\r\n\r\n- ``type``\r\n- ``index_``\r\n- ``precision_step``\r\n- ``ignore_malformed``\r\n- ``coerce``\r\n\r\nThe following types use the same arguments (except for type which is specified automatically)\r\n\r\n- ``Float`` *([float], \\*\\*kwargs)*\r\n- ``Integer`` *([int], \\*\\*kwargs)*\r\n- ``Long`` *([float], \\*\\*kwargs)*\r\n- ``Short`` *([float], \\*\\*kwargs)*\r\n- ``Byte`` *([float], \\*\\*kwargs)*\r\n- ``Tokencount`` *([number],\\*\\*kwargs)*\r\n\r\n**Date** *([date|str] | [year int, month int, day int], \\*\\*kwargs)* and **DateTime** *([datetime|str] | [year int, month int, day int, [hour int, [minute int,[second int, [microsecond int]]]]], \\*\\*kwargs)*\r\n\r\nKeyword args:\r\n\r\n- ``format``\r\n- ``precision_step``\r\n- ``ignore_malformed``\r\n\r\n**Array** - new in 1.0.8\r\n\r\nSpecial type that specifies a list of items that are a single type. Accepts any keyword argument above. ``type_`` keyword specifies the type to be used. Default is string\r\n\r\n**Binary** *()*\r\n\r\nExperimental. Keyword arguments:\r\n\r\n- ``compress``\r\n- ``compress_threshold``\r\n\r\n**IP** *([str])*\r\n\r\nKeyword args:\r\n\r\n- ``precision_step``\r\n\r\n**GeoShape** / **GeoPoint**\r\n\r\nExperimental. Will work as regular objects as well.\r\n\r\n----\r\n\r\nType Functions\r\n--------------\r\n\r\n**create_es_type** *(value)*\r\n\r\nTakes ``value`` and returns the equivalent Elasticsearch type. If an appropriate type cannot be determined then the value itself is returned.\r\n\r\n----\r\n\r\nModels\r\n---------------\r\n\r\nCreate a model by defining the name of the model and extending ``VWBase`` (or a subclass of ``VWBase``).\r\nProperties for the model should be statically defined. They can be ESTypes as described above or as regular\r\nPython types. Values set in the model are defaults in each instance.\r\n\r\nThe ``__type__`` attribute is required and maps to the Elasticsearch ``doctype``. ``__index__`` is recommended\r\nbut if it is not present then the value of ``velociwrapper.config.default_index`` is used.\r\n\r\nExample:\r\n\r\n::\r\n\r\n\tclass User(VWBase):\r\n\t\t__index__ = 'user_index'\r\n\t\t__type__ = 'user'\r\n\t\tusername = String(analyzed=False)\r\n\t\tpassword = String(analyzed=False)\r\n\t\temail = String(analyzed=False)\r\n\t\tname = String()\r\n\t\tprofile_image = String('default.jpg')\r\n\r\n\r\nOr without using ESTypes:\r\n\r\n::\r\n\r\n\tclass User(VWBase):\r\n\t\t__index__ = 'user_index'\r\n\t\t__type__ = 'user'\r\n\t\tusername = ''\r\n\t\tpassword = ''\r\n\t\temail = ''\r\n\t\tname = ''\r\n\t\tprofile_image = ''\r\n\r\nThe added benefit of using ESTypes is specifying the mappings. This helps velociwrapper know what kind of searches to build\r\nand can create the mappings for you, if you haven't specified them yourself.\r\n\r\nOnce models are created they must be committed to save into the Elasticsearch cluster\r\n\r\n::\r\n\r\n\tu = User(\r\n\t\tusername='jsmith', \r\n\t\tpassword=crypt_method('password123'), \r\n\t\temail='jsmith@example.com', \r\n\t\tname='John Smith', \r\n\t\tprofile_image='jsmith.jpg'\r\n\t\t)\r\n\r\n\tu.commit()\r\n\r\nThe call to ``commit()`` generates an id for the document. If you want to explicitly set the id first, you can set the id attribute:\r\n\r\n::\r\n\r\n\tu = User( ... )\r\n\tu.id = 'my-unique-id'\r\n\tu.commit()\r\n\r\n*Be careful!*. IDs have to be unique across all types in your index. If your ID is not unique, the ID specified will be updated by\r\nyour new data. It is recommended to let Velociwrapper handle ID creation unless you're certain of what you're doing.\r\n\r\n**Model API**\r\n\r\n**commit** *()*\r\n\r\nCommits the model to Elasticsearch. New models will be created as new documents. Existing models will be updated.\r\n\r\n**delete** *()*\r\n\r\nDeletes the cooresponding document from Elasticsearch. New operations cannot be performed on the model once it is marked\r\nfor delete.\r\n\r\n**sync** *()*\r\n\r\nSyncs the document in Elasticsearch to the model. Overwrites any uncommitted changes.\r\n\r\n**to_dict** *()*\r\n\r\nConverts the model to a dictionary. Very useful for outputting models to JSON web services. This method is intended to be overridden for\r\ncustom output.\r\n\r\n**more_like_this** *()*\r\n\r\nPerforms a search to get documents that are \"like\" the current document. Returns a VWCollectionGen.\r\n\r\n----\r\n\r\nCollections\r\n------------\r\n\r\nCollections are used to search and return collections of models. Searches can be chained together to create complex queries of Elasticsearch\r\n(much like SQLAlchemy). Currently collections are of one document type only. This may change in a future release.\r\n\r\nExample:\r\n\t\r\n::\r\n\r\n\t# all users named john\r\n\tusers = Users().filter_by(name='John').all()\r\n\r\n\t# users named john who live in texas\r\n\tusers = Users().filter_by(name='John', state='TX').all()\r\n\r\n\t# another way to write the same as above\r\n\tusers = Users().filter_by(name='John').filter_by(state='TX').all()\r\n\r\nBy default chained criteria are joined with \"AND\" (\"must\" in most cases internally). But can be controlled:\r\n\r\n::\r\n\r\n\t# users who live in texas or are named john:\r\n\tusers = Users().filter_by(name='John', state='TX', condition='or').all()\r\n\r\nFor more complex queries see the ``raw()`` method and the QDSL module.\r\n\r\n**Creating Collections**\r\n\r\nCollections can be created on the fly by creating a VWCollection instance and setting ``baseobj`` to the appropriate\r\nmodel. ``baseobj`` must be a subclass of ``VWBase``\r\n\r\n::\r\n\r\n\tusers = VWCollection(baseobj=User)\r\n\r\nThe better way to create a collection is to define it with your model. Subclass VWCollection and set the __model__ property\r\n\r\n::\r\n\r\n\tclass Users(VWCollection):\r\n\t\t__model__ = User\r\n\r\n**Conditions**\r\n\r\nConditions in Elasticsearch are a little tricky. Internally the ``bool`` queries / filters are used. Instead of the traditional\r\n``and``, ``or``, ``not``. Elasticsearch uses ``must``, ``should`` and ``must_not``. To make things a bit more interesting the\r\ntraditional boolean values exist as well and Elasticsearch recommends they be used is certain cases (such as geo filters) \r\nVelociwrapper converts ``and``, ``or``, ``not`` to the Elasticsearch equivalents except in the case of ``search_geo()``.\r\n\r\nThe ``must``, ``should``, ``must_not`` options can be used instead and will work. ``minimum_should_match`` is also available. If \r\nthe explicit options are needed you can use ``explicit_and``, ``explicit_or``, and ``explicit_not``.\r\n\r\nConditions can become complex very quickly. Velociwrapper tries to take a \"do what I mean\" approach to chained conditions. First\r\nthe current filter is checked for a specific condition. If no condition exists then the *preceeding* condition is used. If there\r\nis no preceeding condition, the condition is set to and/must by default.\r\n\r\nExamples:\r\n\r\n::\r\n\r\n\t# get users in named John or Stacy\t\r\n\tusers = Users().filter_by(name='John').filter_by(name='Stacy', condition='or').all()\r\n\r\n\t# equivalent because the second filter_by() will use the preceeding or condition:\r\n\tusers = Users().filter_by(name='John', condition='or').filter_by(name='Stacy').all()\r\n\r\n\t# add another condition, such as state, might not always do what we expect. This would return anyone\r\n\t# who's name is stacy or john or lives in Texas\r\n\tusers = Users().filter_by(name='John').filter_by(name='Stacy', condition='or').filter_by(state='TX').all()\r\n\r\n\t# (john or stacy) and state\r\n\tusers = Users().filter_by(name='John').filter_by(name='Stacy', condition='or').filter_by(state='TX',condition='and').all()\r\n\r\nObviously order matters. For more complex queries the other option is to use the ``raw()`` method and the QDSL module (see below)\r\n\r\n**API**\r\n\r\nMethods marked chainable internally change the search query to affect the output on ``all()``, ``delete()``, and ``one()``. Chainable methods can be\r\ncalled multiple times with different parameters.\r\n\r\n**all** *(\\*\\*kwargs)*\r\n\r\nExecutes the current search and returns ``results_per_page`` results. (default 50). ``results_per_page`` is specified in ``velociwrapper.config.results_per_page``\r\nbut can also be specified by keyword arguments. \r\n\r\nIf no search has been specified, Velociwrapper will call ``match_all``.\r\n\r\nIf no results are matched ``all()`` returns an empty VWCollectionGen.\r\n\r\nArguments:\r\n\r\n- ``results_per_page`` *int*: number of results to return\r\n- ``size`` *int*: same as results_per_page\r\n- ``start`` *int*: Record count to start with\r\n\r\n**clear_previous_search** *()*\r\n\r\nClear all search parameters and reset the object. Even after a call to an output method the search can be output again. This allows the collection to be reused.\r\nGenerally its better to create a new object.\r\n\r\n**commit** *([callback=callable])*\r\n\r\nBulk commits a list of items specified on ``__init__()`` or if no items were specified will bulk commit against the items matched in the current search. (be careful! Calling something like Users().commit() will commit all users!)\r\n\r\nThe ``callback`` argument should be a callable. The raw item will be passed to it and it must return either a ``dict`` or a ``VWBase`` \r\n(model) object.  Note that velociwrapper does not call each model's ``commit()`` or ``to_dict()`` methods but rather issues the request\r\nin bulk. Thus you cannot affect the behavior by overriding these methods. Use the ``callback`` to make changes or change the items before\r\npassing them to the collection.\r\n\r\nAs of 2.0 it is also possible to register a callback to manipulate items in the commit. See \"Callbacks\".\r\n\r\n**count** *()*\r\n\r\nReturns the total number of documents matched (not that will be returned!) by the search. \r\n\r\n**delete** *(\\*\\*kwargs)*\r\n\r\nDelete the records specified by the search query.\r\n\r\n**delete_in** *(ids=list)*\r\n\r\nDelete the records specified by a list of ids. Equivalent to:\r\n\r\n::\r\n\t\r\n\tUsers().filter_by(ids=list_of_ids).delete()\r\n\r\n**exact** *(field=str, value=mixed)*\r\n\r\nChainable. Find records where ``field`` is the exact ``value``. String based fields **must** be specified as ``not_analyzed`` in the index. Otherwise results\r\nmay not be as expected.  ``exact()`` is more for completeness. ``filter_by()`` uses exact values when available. The only difference is ``exists()``\r\nwill warn if the field cannot be searched while ``filter_by()`` silently converts to a query.\r\n\r\nKeyword arguments:\r\n\r\n- ``boost`` *float*: An explicit boost value for this boolean query\r\n- ``condition`` *str*: \"and\",\"or\",\"not\",\"explicit_and\",\"explicit_or\",\"explicit_not\",\r\n- ``minimum_should_match`` *int*: When executing a should (or) query, specify the number of options that should match to return the document. Default = 1\r\n- ``with_explicit`` *str*: \"and\",\"or\",\"not\". Only used if explicit conditions exist and there's a question of how an additional condtion should be added to the query. \r\n\r\n**exists** *(field, [kwargs])*\r\n\r\nChainable. Find records if the specified field exists is the document.\r\n\r\nKeyword arguments:\r\n\r\n- ``boost`` *float*: An explicit boost value for this boolean query\r\n- ``condition`` *str*: \"and\",\"or\",\"not\",\"explicit_and\",\"explicit_or\",\"explicit_not\",\r\n- ``minimum_should_match`` *int*: When executing a should (or) query, specify the number of options that should match to return the document. Default = 1\r\n- ``with_explicit`` *str*: \"and\",\"or\",\"not\". Only used if explicit conditions exist and there's a question of how an additional condtion should be added to the query. \r\n\r\n**filter_by** *([condition], kwargs)*\r\n\r\nChainable. Filter or query elasticsearch for ``field=\"search\"``. Automatically creates filters or queries based on field mappings. If the ``search`` parameter is a list, filter_by will create\r\nan ``in()`` filter / query. ``condition`` can be set as the first argument or passed as a keyword argument.\r\n\r\nKeyword arguments\r\n\r\n- ``[field]`` *str*: A field in the document set to the value to try to find.\r\n- ``id`` *value*: Explicitly search for particular id. \r\n- ``ids`` *list*: Explicitly search for using a list of ids. \r\n- ``boost`` *float*: An explicit boost value for this boolean query\r\n- ``condition`` *str*: \"and\",\"or\",\"not\",\"explicit_and\",\"explicit_or\",\"explicit_not\",\r\n- ``minimum_should_match`` *int*: When executing a should (or) query, specify the number of options that should match to return the document. Default = 1\r\n- ``with_explicit`` *str*: \"and\",\"or\",\"not\". Only used if explicit conditions exist and there's a question of how an additional condtion should be added to the query. \r\n\r\n**multi_match** *(fields=list,query=str,\\*\\*kwargs)*\r\n\r\nChainable. Search the list of fields for the value of query. Accepts standard kwargs arguments.\r\n\r\n**get** *(id=value)*\r\n\r\nReturns the single record specified by ``id`` or ``None`` if it does not exist.\r\n\r\n**get_in** *(ids=list)*\r\n\r\nReturns a list of records specified by the list of ids or an empty list if no ids exist. Note this method cannot be sorted. If sorting is needed it is better to call\r\n\r\n::\r\n    \r\n    filter_by(ids=list).sort(...).all()\r\n\r\n**get_like_this** *(id)*\r\n\r\nReturns records like the document specified by id or an empty list if none exists. Note this method cannot be sorted.\r\n\r\n**__init__** *([items=list],[\\*\\*kwargs])*\r\n\r\nCreate a collection. If ``items`` are specified they are stored internally to ``commit()`` in bulk. Stored items must be models (subclassing ``VWBase``) or ``dict``.\r\n\r\nKeyword arguments:\r\n\r\n- ``bulk_chunk_size`` *int*: override default chunk size for this collection\r\n- ``results_per_page`` *int*\r\n\r\n\r\n**__len__** *()*\r\n\r\nSame as ``count()``. Allows for the entire collection to be passed to ``len()``\r\n\r\n**missing** *(field=str,\\*\\*kwargs)*\r\n\r\nChainable. Finds records where the specified ``field`` is missing\r\n\r\nKeyword arguments:\r\n\r\n- ``boost`` *float*: An explicit boost value for this boolean query\r\n- ``condition`` *str*: \"and\",\"or\",\"not\",\"explicit_and\",\"explicit_or\",\"explicit_not\",\r\n- ``minimum_should_match`` *int*: When executing a should (or) query, specify the number of options that should match to return the document. Default = 1\r\n- ``with_explicit`` *str*: \"and\",\"or\",\"not\". Only used if explicit conditions exist and there's a question of how an additional condtion should be added to the query. \r\n\r\n**one** *()*\r\n\r\nExecutes the search and returns the first record only. Raises ``NoResultFound`` is the search did not match any documents.\r\n\r\n**range** *(field=str, \\*\\*kwargs)*\r\n\r\nChainable. Filters the results by a range of values in ``field``. The keyword arguments coorespond to arguments used by the range filter\r\nin Query DSL: http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-range-query.html\r\n\r\nOther search keywords are available except for ``boost``. ``boost`` affects the range query itself. Keyword arguemtns are:\r\n\r\n- ``gte`` *number or date*: greater than or equal\r\n- ``gt`` *number or date*: greater than\r\n- ``lte`` *number or date*: less than or equal\r\n- ``lt`` *number or date*: less than\r\n- ``boost`` *float*: boost value for the range query itself\r\n- ``time_zone`` *str*: timezone offset. Only used if comparison is a date and doesn't contain a timezone offset already.\r\n- ``condition`` *str*: \"and\",\"or\",\"not\",\"explicit_and\",\"explicit_or\",\"explicit_not\",\r\n- ``minimum_should_match`` *int*: When executing a should (or) query, specify the number of options that should match to return the document. Default = 1\r\n- ``with_explicit`` *str*: \"and\",\"or\",\"not\". Only used if explicit conditions exist and there's a question of how an additional condtion should be added to the query. \r\n\r\n**raw** *(rawquery=dict)*\r\n\r\nExecute a raw Query DSL query.  Chainable but all other search filters are ignored. Can still be used with ``sort()``.\r\n\r\n***search** *(query=string)*\r\n\r\nExecute a Lucene query against the server. Chainable.\r\n\r\n**search_geo** *(field=str,distance=float,lat=float,lon=float,\\*\\*kwargs)*\r\n\r\nChainable. Filter the search based on distance from a geopoint.\r\n\r\n- ``boost`` *float*: An explicit boost value for this boolean query\r\n- ``condition`` *str*: \"and\",\"or\",\"not\",\"explicit_and\",\"explicit_or\",\"explicit_not\",\r\n- ``minimum_should_match`` *int*: When executing a should (or) query, specify the number of options that should match to return the document. Default = 1\r\n- ``with_explicit`` *str*: \"and\",\"or\",\"not\". Only used if explicit conditions exist and there's a question of how an additional condtion should be added to the query. \r\n\r\n**sort** *(\\*\\*kwargs)*\r\n\r\nChainable (and can appear anywhere before an output method, including by having other filters changed to it). Arguments are ``field=asc|desc``. ``asc`` sorts the field\r\nfirst to last. ``desc`` sorts the field last to first. ``asc`` is the default.\r\n\r\n----\r\n\r\nQuery Bodies with ``querybuilder.QueryBody`` \r\n--------------------------------------------\r\n\r\nUnderlying chainable methods is the ``querybuilder.QueryBody`` class. This class helps build simple query bodies\r\nfor Elasticsearch but attempts not to get too crazy. It stores an internal structure of the query and then\r\nbuilds it into a ``dict`` that can be passed to the underlying Elasticsearch client.  The class is used internally\r\nby ``VWCollection`` but you could use it directly to build queries to then pass to the ``raw()`` method.\r\n\r\n``QueryBody`` only supports queries and filters. For other wrappers, such as constant_score, you'll need to manually\r\nbuild the queries by hand or with the ``QDSL`` functions described below.\r\n\r\n**QueryBody methods**\r\n\r\n**chain** *(self, newpart=dict, \\*\\*kwargs)*\r\n\r\nChains a new part of the query into the existing query. Newpart must be a ``dict`` with additional query parameters\r\nto pass to Elasticsearch. Note that ``newpart`` is not checked for correctness. \r\n\r\nReturns ``self`` so additional methods can be called. \r\n\r\nKeyword Arguments:\r\n\r\n- ``type`` *string*: either \"query\" or \"filter\". If not specified checks ``newpart`` for one of these keywords. Otherwise uses \"query\"\r\n- ``condition`` *string*: must|should|must_not|and|or|not. Defaults to \"must\". Specifies how this part of the query is treated in relation to the existing query\r\n- ``with_explicit`` *string*: and|or|not. Included for legacy purposes. Overrides ``condition`` and is useful if a nested bool was manually created. Generally should not be used.\r\n\r\n**is_filtered** *(self)*\r\n\r\nReturns ``True`` if the current query body contains a filter.\r\n\r\n**is_query** *(self)*\r\n\r\nReturns ``True`` is the current query body contains a query other than ``match_all {}``\r\n\r\n**build** *(self)*\r\n\r\nBuilds the current query into a representation understood by Elasticsearch. Returns ``dict``\r\n\r\n----\r\n\r\nQDSL and Building Raw Queries\r\n-----------------------------\r\n\r\n``velociwrapper.qdsl`` contains functions to help make writing QDSL easier.\r\n\r\n**QDSL Functions**\r\n\r\n**query** *(params=dict)*\r\n\r\nReturns ``params`` wrapped by ``{ \"query\": params }``\r\n\r\n**filter_** *(params=dict)*\r\n\r\nReturns ``params`` wrapped by ``{ \"filter\": params }``.\r\n\r\nNote the \"_\" appended to ``filter_`` to prevent confusion with Python's ``filter()``\r\n\r\n**match** *(field=str,value=str|dict,\\*\\*kwargs)*\r\n\r\nReturns ``{\"match\": { field: { \"query\": value } } }``\r\n\r\nAdditional keyword arguments should be Elasticsearch arguments on ``match``\r\n\r\n**match_phrase** *(field=str,value=str|dict,\\*\\*kwargs)*\r\n\r\nEquivalent to ``match(field,value,type=\"phrase\")``\r\n\r\n**match_phrase_prefix** *(field=str,value=str|dict,\\*\\*kwargs)*\r\n\r\nEquivalent to ``match(field,value,type=\"phrase_prefix\")``\r\n\r\n**multi_match** *(query=str|dict, fields=list,\\*\\*kwargs)*\r\n\r\nReturns ``{\"multi_match\": {\"query\": query, \"fields\": fields } }``\r\n\r\nAdditional keyword arguments should be Elasticsearch arguments on ``multi_match``\r\n\r\n**bool** *(\\*args,\\*\\*kwargs)*\r\n\r\nArgs are any number of dicts containing \"must\", \"should\" or \"must_not\" keys. Keyword arguments\r\nare Elasticsearch options for ``bool`` such as ``minimum_should_match``\r\n\r\nExample:\r\n\r\n::\r\n\r\n\tfrom velociwrapper.qdsl import bool, must, must_not, match\r\n\tmybool = bool(\r\n\t\tmust( match('foo','some value') ), \r\n\t\tmust_not( match( 'bar', 'some other value' ) )\r\n\t)\r\n\r\nSpecial Keyword arguments\r\n\r\n- *__vw_set_current* *dict*: set a current ``bool`` dictionary that will be updated rather than creating a blank one.\r\n\r\n**must** *(params=str|dict, value=str|dict|None,\\*\\*kwargs)*\r\n\r\nCreates a ``must`` arguement for ``bool``. If params is a ``dict`` then it is passed on directly. If it is a string or value\r\nis set then the params are treated as a field name and passed to ``term``.\r\n\r\nExample:\r\n\r\n::\r\n\r\n\tmust( match('foo', 'some value' ) )\r\n\t# returns { \"must\": { \"match\": { \"foo\": {\"query\": \"some value\" } } } }\r\n\r\n\tmust('foo', 'some value' ) )\r\n\t# returns { \"must\": { \"term\" { \"foo\": {\"value\": \"some value\" } } } }\r\n\r\n**must_not** *(params=str|dict,value=str|dict|None,\\*\\*kwargs)*\r\n\r\nLike ``must`` but uses \"must_not\"\r\n\r\n**should** *(params=str|dict,value=str|dict|None,\\*\\*kwargs)*\r\n\r\nLike ``must`` but uses \"should\"\r\n\r\n**term** *(field=str, value=str,\\*\\*kwargs)*\r\n\r\nLike ``match`` but for filters\r\n\r\n**terms** *(field=str,value=list,\\*\\*kwargs)*\r\n\r\nLike ``term`` but values are a list of strings to match in a field.\r\n\r\n**boosting** *(\\*args, \\*\\*kwargs)*\r\n\r\nSimilar to ``bool`` allows any number of dicts with the key ``positive`` or ``negative``. Keyword arguments are options\r\npassed to ``boosting``\r\n\r\n**positive** *(field,value)*\r\n\r\nReturns ``{ \"positive\": { \"term\": { field: value } } }``\r\n\r\n**negative** *(field,value)*\r\n\r\nReturns ``{ \"negative\": {\"term\": { field:value } } }``\r\n\r\n**common** *(field, value, \\*\\*kwargs)*\r\n\r\nReturns ``{ \"common\": { field: { \"query\": value } } }``\r\n\r\nKeyword arguments are passed as additional key values to the ``field`` dict.\r\n\r\n**constant_score** *(\\*args, \\*\\*kwargs)*\r\n\r\nArguments should be ``dict``. A single argument is wrapped directly by ``constant_score``. In the case of multiple arguments the function searches each\r\nfor ``query`` or ``filter`` keys to wrap in the output.\r\n\r\n**filtered** *(\\*args, \\*\\*kwargs)*\r\n\r\nArguments should be ``dict``. A single argument is wrapped directly by ``filtered``. In the case of multiple arguments the function searches each\r\nfor ``query`` or ``filter`` keys to wrap in the output.\r\n\r\nAdditional keyword arguments are set on the ``filtered`` dict.\r\n\r\n**function_score** *(\\*args, \\*\\*kwargs)*\r\n\r\nArguments should be ``dict``. A single argument is wrapped directly by ``function_score``. In the case of multiple arguments the function searches each\r\nfor ``query``, ``filter``, ``FUNCTION``, or ``functions`` keys to wrap in the output. No magic happens here to check the validity of the functions!\r\n\r\nKeyword arguments are set on the ``function_score`` dict.\r\n\r\n**fuzzy**\r\n\r\n**ids**\r\n\r\n**query_term**\r\n\r\n**indices**\r\n\r\n**match_all**\r\n\r\n**more_like_this**\r\n\r\n**nested**\r\n\r\n**prefix**\r\n\r\n**query_string**\r\n\r\n**simple_query_string**\r\n\r\n**range**\r\n\r\n**regexp**\r\n\r\n**span_term**\r\n\r\n**span_first**\r\n\r\n**span_multi**\r\n\r\n**span_near**\r\n\r\n**span_not**\r\n\r\n**span_or**\r\n\r\n**wildcard**\r\n\r\n**and_**\r\n\r\n**or_**\r\n\r\n**not_**\r\n\r\n**exists**\r\n\r\n**geo_bounding_box**\r\n\r\n**geo_distance**\r\n\r\n**geo_range**\r\n\r\n**geo_polygon**\r\n\r\n**geo_shape**\r\n\r\n**geohash_cell**\r\n\r\n**has_child**\r\n\r\n**has_parent**\r\n\r\n**missing**\r\n\r\n**script**\r\n\r\n**type_**\r\n\r\n\r\n----\r\n\r\nMapper\r\n------\r\n\r\nUse the mapper by importing it:\r\n\r\n::\r\n\r\n\tfrom velociwrapper.mapper import Mapper\r\n\r\nThe Mapper class has utilities for managing the Elasticsearch index.\r\n\r\n**Mapper API**\r\n\r\n**get_index_map** *(\\*\\*kwargs)*\r\n\r\nSearches for currently loaded VWBase models and returns the their indexes as defined by code, along with their mappings. The only keyword argument is ``index``, passed to specify \r\na particular index or group of indexes (must be a ``str`` or ``list``).\r\n\r\n**get_server_map** *(\\*\\*kwargs)*\r\n\r\n*New in version 1.0.10*. Like *get_index_map()*, but returns the mapping as saved on the server.\r\n\r\n**create_indices** *(\\*\\*kwargs)*\r\n\r\nCreates indexes based on currently loaded VWBase models or for the index or indexes specified by the ``index`` keyword argument.\r\n\r\n**get_index_for_alias** *(alias=str)*\r\n\r\nReturn the name of the index for the specified ``alias``. If ``alias`` is an index, then the same name will be returned.\r\n\r\n**reindex** *(index=str,newindex=str,\\*\\*kwargs)*\r\n\r\nRe-indexes the specified index to a new index. Useful for making model changes and then creating them in Elastic search\r\n\r\nKeyword arguments\r\n\r\n- ``alias_name`` *string*: specify a new alias name when re-mapping an alias. If omitted the previous alias name is used.\r\n- ``remap_alias`` *bool*: Aliases the index under a new name. Useful for making on-the-fly changes\r\n\r\n**describe** *(cls=class)*\r\n\r\nOutput the index mapping for a VWBase class.\r\n\r\n----\r\n\r\nCallbacks\r\n---------\r\n\r\nThere are several events built-in to Velociwrapper on which you can register callbacks. \r\nCallbacks are registered at the class level so all instances will have the callback. You \r\ncan also register multiple methods for the same event. Callbacks recieve the instance and \r\na single (optional) argument. The argument is returned. In the case of multiple callbacks \r\non an event, the callbacks are fired in the order they were registered. The return value \r\nfrom one method is passed to the next as the argument.\r\n\r\nExample:\r\n\r\n::\r\n\r\n    from your_models import Document\r\n    \r\n    # check a user for entry in another database\r\n    def doc_database_check( vwinst, argument=None ):\r\n        if not doc_in_database(vwinst.id):\r\n            insert_into_database( vwinst.id, vwinst.name, vwinst.content ) # or whatever\r\n            return argument \r\n\r\n\tDocument.register_callback( 'after_commit', doc_database_check )\r\n\r\nCallbacks are defined in the ``VWCallback`` class in base.py. ``VWCollection`` and ``VWBase`` \r\nderive from ``VWCallback``\r\n\r\n**Callback API**\r\n\r\n**register_callback** *(cls, callback_event=str, callback=callable)* *- classmethod*\r\n\r\nRegister a callback for the event *callback_event* on the collection or base class. This is a class method,\r\nthe callback becomes active on all instances.\r\n\r\n**deregister_callback** *(cls, callback_event=str, callback=callable|str)* *- classmethod*\r\n\r\nDeregister a callback for the event *callback_event* by its name or original function *callback*. Returns None\r\neven if there was not a callback by the name or for the event.\r\n\r\n**execute_callbacks** *(self, event=string, argument=None, \\*\\*kwargs)*\r\n\r\nExecutes the current instances callbacks for *event* in the order they were registered. Returns *argument*.\r\nIf no callback was registered for the event the method returns *None*\r\n\r\n**Available Events**\r\n\r\n*before_manual_create_model*\r\n\r\nExecuted when a model instance is created directly but not when the model is created as the result of a search.\r\n*argument* is ignored, only the model's instance is passed. The event fires before mapping information is copied\r\nfrom the class and before the id is created.  An example use is a custom ID creation method.\r\n\r\n*after_manual_create_model*\r\n\r\nExecuted when a model instance is created directly but not when the model is created as the result of a search.\r\n*argument* is ignored, only the model's instance is passed. The event fires after the class variables are copied\r\nto the instance, *id* is created, and the *__index__* is set.\r\n\r\n*on_delete*\r\n\r\nExecuted when ``commit()`` is called on a deleted instance. Fires just before the underlying DELETE to Elasticsearch.\r\nArgument is ignored. Does not execute on a bulk delete call in ``VWCollection``.\r\n\r\n*before_commit*\r\n\r\nExecuted before the INDEX call to Elasticsearch. The argument is ignored. Does not execute on bulk commit calls in\r\n``VWCollection``.\r\n\r\n*after_commit*\r\n\r\nExecuted after the INDEX call to Elasticsearch. The argument is ignored. Does not execute on bulk commit calls in\r\n``VWCollection``.\r\n\r\n*before_sync*\r\n\r\nExecuted before retrieveing the underlying document from Elasticsearch to sync the object. The argument is ignored. \r\n\r\n*after_sync*\r\n\r\nExecuted after variables from Elasticsearch have overwritten object attributes. The argument is ignored.\r\n\r\n*before_query_build*\r\n\r\nExecuted just before a search query is created. The argument is the current ``QueryBody``.\r\n\r\n*after_query_build*\r\n\r\nExecutes after the search query is created as a ``dict``. The argument is the ``dict`` to be passed to the Elasticsearch client.\r\n\r\n*on_bulk_commit*\r\n\r\nExecutes for each item before being appended to a bulk commit operation. The argument is the item. The item can be a \r\n``dict`` source document or a ``VWBase`` object depending on what was passed to the collections items. (If the commit\r\ncriteria was a search query then ``VWBase`` objects are passed.\r\n\r\n*before_auto_create_model*\r\n\r\nExecutes after a source document is retrieved from Elasticsearch but before the document is converted to a model\r\ninstance. Note this does not fire until accessed in the ``VWCollectionGen`` generator. The argument passed is the\r\nsource document\r\n\r\n*after_auto_create_model*\r\n\r\nExecutes after the a source document result is converted to a model instance. Does not occur until the model \r\ninstance is accessed in the generator. Due to the way the generator works the instance passed to the callback\r\nis empty, while the argument is the newly created instance to manipulate.\r\n\r\n**Creating New Events**\r\n\r\nYou can register your own events and fire them yourself.\r\n\r\n::\r\n\r\n\t# register an event when your generic document is something specific\r\n\tdef is_pdf(inst, argument=None, **kwargs):\r\n\t\t# do something\r\n\t\treturn argument\r\n\r\n\tDocument.register_callback( 'on_edit', is_pdf )\r\n\r\n\t# then somewhere in your code (maybe an edit function?)\r\n\tdocument_instance.execute_callbacks('on_edit')\r\n\r\n----\r\n\r\nAUTHOR\r\n------\r\n\r\nChris Brown, Drew Goin and Boyd Hitt \r\n\r\n----\r\n\r\nCOPYRIGHT\r\n---------\r\n\r\nCopyright (c) 2015 Constituent Voice LLC\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}